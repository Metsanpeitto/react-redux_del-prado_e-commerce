{"id":"../node_modules/webpack/node_modules/@webassemblyjs/wasm-edit/esm/apply.js","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655165833},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/@webassemblyjs/wasm-edit/package.json","includedInParent":true,"mtime":1594578778153},{"name":"@webassemblyjs/wasm-gen","loc":{"line":5,"column":27},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/@webassemblyjs/wasm-edit/esm/apply.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/@webassemblyjs/wasm-gen/esm/index.js"},{"name":"@webassemblyjs/wasm-gen/lib/encoder","loc":{"line":6,"column":26},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/@webassemblyjs/wasm-edit/esm/apply.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/@webassemblyjs/wasm-gen/lib/encoder/index.js"},{"name":"@webassemblyjs/ast","loc":{"line":7,"column":113},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/@webassemblyjs/wasm-edit/esm/apply.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/@webassemblyjs/ast/esm/index.js"},{"name":"@webassemblyjs/helper-wasm-section","loc":{"line":8,"column":96},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/@webassemblyjs/wasm-edit/esm/apply.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/@webassemblyjs/helper-wasm-section/esm/index.js"},{"name":"@webassemblyjs/helper-buffer","loc":{"line":9,"column":38},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/@webassemblyjs/wasm-edit/esm/apply.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/@webassemblyjs/helper-buffer/esm/index.js"},{"name":"@webassemblyjs/helper-wasm-bytecode","loc":{"line":10,"column":34},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/@webassemblyjs/wasm-edit/esm/apply.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/@webassemblyjs/helper-wasm-bytecode/esm/index.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyOperations = applyOperations;\n\nvar _wasmGen = require(\"@webassemblyjs/wasm-gen\");\n\nvar _encoder = require(\"@webassemblyjs/wasm-gen/lib/encoder\");\n\nvar _ast = require(\"@webassemblyjs/ast\");\n\nvar _helperWasmSection = require(\"@webassemblyjs/helper-wasm-section\");\n\nvar _helperBuffer = require(\"@webassemblyjs/helper-buffer\");\n\nvar _helperWasmBytecode = require(\"@webassemblyjs/helper-wasm-bytecode\");\n\nfunction _sliceIterator(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _slicedToArray(arr, i) {\n  if (Array.isArray(arr)) {\n    return arr;\n  } else if (Symbol.iterator in Object(arr)) {\n    return _sliceIterator(arr, i);\n  } else {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n}\n\nfunction shiftLocNodeByDelta(node, delta) {\n  (0, _ast.assertHasLoc)(node); // $FlowIgnore: assertHasLoc ensures that\n\n  node.loc.start.column += delta; // $FlowIgnore: assertHasLoc ensures that\n\n  node.loc.end.column += delta;\n}\n\nfunction applyUpdate(ast, uint8Buffer, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      oldNode = _ref2[0],\n      newNode = _ref2[1];\n\n  var deltaElements = 0;\n  (0, _ast.assertHasLoc)(oldNode);\n  var sectionName = (0, _helperWasmBytecode.getSectionForNode)(newNode);\n  var replacementByteArray = (0, _wasmGen.encodeNode)(newNode);\n  /**\n   * Replace new node as bytes\n   */\n\n  uint8Buffer = (0, _helperBuffer.overrideBytesInBuffer)(uint8Buffer, // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.start.column, // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.end.column, replacementByteArray);\n  /**\n   * Update function body size if needed\n   */\n\n  if (sectionName === \"code\") {\n    // Find the parent func\n    (0, _ast.traverse)(ast, {\n      Func: function Func(_ref3) {\n        var node = _ref3.node;\n        var funcHasThisIntr = node.body.find(function (n) {\n          return n === newNode;\n        }) !== undefined; // Update func's body size if needed\n\n        if (funcHasThisIntr === true) {\n          // These are the old functions locations informations\n          (0, _ast.assertHasLoc)(node);\n          var oldNodeSize = (0, _wasmGen.encodeNode)(oldNode).length;\n          var bodySizeDeltaBytes = replacementByteArray.length - oldNodeSize;\n\n          if (bodySizeDeltaBytes !== 0) {\n            var newValue = node.metadata.bodySize + bodySizeDeltaBytes;\n            var newByteArray = (0, _encoder.encodeU32)(newValue); // function body size byte\n            // FIXME(sven): only handles one byte u32\n\n            var start = node.loc.start.column;\n            var end = start + 1;\n            uint8Buffer = (0, _helperBuffer.overrideBytesInBuffer)(uint8Buffer, start, end, newByteArray);\n          }\n        }\n      }\n    });\n  }\n  /**\n   * Update section size\n   */\n\n\n  var deltaBytes = replacementByteArray.length - ( // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.end.column - oldNode.loc.start.column); // Init location informations\n\n  newNode.loc = {\n    start: {\n      line: -1,\n      column: -1\n    },\n    end: {\n      line: -1,\n      column: -1\n    }\n  }; // Update new node end position\n  // $FlowIgnore: assertHasLoc ensures that\n\n  newNode.loc.start.column = oldNode.loc.start.column; // $FlowIgnore: assertHasLoc ensures that\n\n  newNode.loc.end.column = // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.start.column + replacementByteArray.length;\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\n\nfunction applyDelete(ast, uint8Buffer, node) {\n  var deltaElements = -1; // since we removed an element\n\n  (0, _ast.assertHasLoc)(node);\n  var sectionName = (0, _helperWasmBytecode.getSectionForNode)(node);\n\n  if (sectionName === \"start\") {\n    var sectionMetadata = (0, _ast.getSectionMetadata)(ast, \"start\");\n    /**\n     * The start section only contains one element,\n     * we need to remove the whole section\n     */\n\n    uint8Buffer = (0, _helperWasmSection.removeSections)(ast, uint8Buffer, \"start\");\n\n    var _deltaBytes = -(sectionMetadata.size.value + 1);\n    /* section id */\n\n\n    return {\n      uint8Buffer: uint8Buffer,\n      deltaBytes: _deltaBytes,\n      deltaElements: deltaElements\n    };\n  } // replacement is nothing\n\n\n  var replacement = [];\n  uint8Buffer = (0, _helperBuffer.overrideBytesInBuffer)(uint8Buffer, // $FlowIgnore: assertHasLoc ensures that\n  node.loc.start.column, // $FlowIgnore: assertHasLoc ensures that\n  node.loc.end.column, replacement);\n  /**\n   * Update section\n   */\n  // $FlowIgnore: assertHasLoc ensures that\n\n  var deltaBytes = -(node.loc.end.column - node.loc.start.column);\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\n\nfunction applyAdd(ast, uint8Buffer, node) {\n  var deltaElements = +1; // since we added an element\n\n  var sectionName = (0, _helperWasmBytecode.getSectionForNode)(node);\n  var sectionMetadata = (0, _ast.getSectionMetadata)(ast, sectionName); // Section doesn't exists, we create an empty one\n\n  if (typeof sectionMetadata === \"undefined\") {\n    var res = (0, _helperWasmSection.createEmptySection)(ast, uint8Buffer, sectionName);\n    uint8Buffer = res.uint8Buffer;\n    sectionMetadata = res.sectionMetadata;\n  }\n  /**\n   * check that the expressions were ended\n   */\n\n\n  if ((0, _ast.isFunc)(node)) {\n    // $FlowIgnore\n    var body = node.body;\n\n    if (body.length === 0 || body[body.length - 1].id !== \"end\") {\n      throw new Error(\"expressions must be ended\");\n    }\n  }\n\n  if ((0, _ast.isGlobal)(node)) {\n    // $FlowIgnore\n    var body = node.init;\n\n    if (body.length === 0 || body[body.length - 1].id !== \"end\") {\n      throw new Error(\"expressions must be ended\");\n    }\n  }\n  /**\n   * Add nodes\n   */\n\n\n  var newByteArray = (0, _wasmGen.encodeNode)(node); // The size of the section doesn't include the storage of the size itself\n  // we need to manually add it here\n\n  var start = (0, _ast.getEndOfSection)(sectionMetadata);\n  var end = start;\n  /**\n   * Update section\n   */\n\n  var deltaBytes = newByteArray.length;\n  uint8Buffer = (0, _helperBuffer.overrideBytesInBuffer)(uint8Buffer, start, end, newByteArray);\n  node.loc = {\n    start: {\n      line: -1,\n      column: start\n    },\n    end: {\n      line: -1,\n      column: start + deltaBytes\n    }\n  }; // for func add the additional metadata in the AST\n\n  if (node.type === \"Func\") {\n    // the size is the first byte\n    // FIXME(sven): handle LEB128 correctly here\n    var bodySize = newByteArray[0];\n    node.metadata = {\n      bodySize: bodySize\n    };\n  }\n\n  if (node.type !== \"IndexInFuncSection\") {\n    (0, _ast.orderedInsertNode)(ast.body[0], node);\n  }\n\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\n\nfunction applyOperations(ast, uint8Buffer, ops) {\n  ops.forEach(function (op) {\n    var state;\n    var sectionName;\n\n    switch (op.kind) {\n      case \"update\":\n        state = applyUpdate(ast, uint8Buffer, [op.oldNode, op.node]);\n        sectionName = (0, _helperWasmBytecode.getSectionForNode)(op.node);\n        break;\n\n      case \"delete\":\n        state = applyDelete(ast, uint8Buffer, op.node);\n        sectionName = (0, _helperWasmBytecode.getSectionForNode)(op.node);\n        break;\n\n      case \"add\":\n        state = applyAdd(ast, uint8Buffer, op.node);\n        sectionName = (0, _helperWasmBytecode.getSectionForNode)(op.node);\n        break;\n\n      default:\n        throw new Error(\"Unknown operation\");\n    }\n    /**\n     * Resize section vec size.\n     * If the length of the LEB-encoded size changes, this can change\n     * the byte length of the section and the offset for nodes in the\n     * section. So we do this first before resizing section byte size\n     * or shifting following operations' nodes.\n     */\n\n\n    if (state.deltaElements !== 0 && sectionName !== \"start\") {\n      var oldBufferLength = state.uint8Buffer.length;\n      state.uint8Buffer = (0, _helperWasmSection.resizeSectionVecSize)(ast, state.uint8Buffer, sectionName, state.deltaElements); // Infer bytes added/removed by comparing buffer lengths\n\n      state.deltaBytes += state.uint8Buffer.length - oldBufferLength;\n    }\n    /**\n     * Resize section byte size.\n     * If the length of the LEB-encoded size changes, this can change\n     * the offset for nodes in the section. So we do this before\n     * shifting following operations' nodes.\n     */\n\n\n    if (state.deltaBytes !== 0 && sectionName !== \"start\") {\n      var _oldBufferLength = state.uint8Buffer.length;\n      state.uint8Buffer = (0, _helperWasmSection.resizeSectionByteSize)(ast, state.uint8Buffer, sectionName, state.deltaBytes); // Infer bytes added/removed by comparing buffer lengths\n\n      state.deltaBytes += state.uint8Buffer.length - _oldBufferLength;\n    }\n    /**\n     * Shift following operation's nodes\n     */\n\n\n    if (state.deltaBytes !== 0) {\n      ops.forEach(function (op) {\n        // We don't need to handle add ops, they are positioning independent\n        switch (op.kind) {\n          case \"update\":\n            shiftLocNodeByDelta(op.oldNode, state.deltaBytes);\n            break;\n\n          case \"delete\":\n            shiftLocNodeByDelta(op.node, state.deltaBytes);\n            break;\n        }\n      });\n    }\n\n    uint8Buffer = state.uint8Buffer;\n  });\n  return uint8Buffer;\n}"},"sourceMaps":null,"error":null,"hash":"ba278c9c70de1c0b9ef042b5740075c5","cacheData":{"env":{}}}