{"id":"../node_modules/cross-spawn/lib/parse.js","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655291184},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/cross-spawn/package.json","includedInParent":true,"mtime":1594306879762},{"name":"path","loc":{"line":3,"column":21},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/cross-spawn/lib/parse.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/path-browserify/index.js"},{"name":"nice-try","loc":{"line":4,"column":24},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/cross-spawn/lib/parse.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/nice-try/src/index.js"},{"name":"./util/resolveCommand","loc":{"line":5,"column":31},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/cross-spawn/lib/parse.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/cross-spawn/lib/util/resolveCommand.js"},{"name":"./util/escape","loc":{"line":6,"column":23},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/cross-spawn/lib/parse.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/cross-spawn/lib/util/escape.js"},{"name":"./util/readShebang","loc":{"line":7,"column":28},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/cross-spawn/lib/parse.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/cross-spawn/lib/util/readShebang.js"},{"name":"semver","loc":{"line":8,"column":23},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/cross-spawn/lib/parse.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/semver/semver.js"},{"name":"process","parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/cross-spawn/lib/parse.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/process/browser.js"}],"generated":{"js":"var process = require(\"process\");\n'use strict';\n\nconst path = require('path');\n\nconst niceTry = require('nice-try');\n\nconst resolveCommand = require('./util/resolveCommand');\n\nconst escape = require('./util/escape');\n\nconst readShebang = require('./util/readShebang');\n\nconst semver = require('semver');\n\nconst isWin = process.platform === 'win32';\nconst isExecutableRegExp = /\\.(?:com|exe)$/i;\nconst isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i; // `options.shell` is supported in Node ^4.8.0, ^5.7.0 and >= 6.0.0\n\nconst supportsShellOption = niceTry(() => semver.satisfies(process.version, '^4.8.0 || ^5.7.0 || >= 6.0.0', true)) || false;\n\nfunction detectShebang(parsed) {\n  parsed.file = resolveCommand(parsed);\n  const shebang = parsed.file && readShebang(parsed.file);\n\n  if (shebang) {\n    parsed.args.unshift(parsed.file);\n    parsed.command = shebang;\n    return resolveCommand(parsed);\n  }\n\n  return parsed.file;\n}\n\nfunction parseNonShell(parsed) {\n  if (!isWin) {\n    return parsed;\n  } // Detect & add support for shebangs\n\n\n  const commandFile = detectShebang(parsed); // We don't need a shell if the command filename is an executable\n\n  const needsShell = !isExecutableRegExp.test(commandFile); // If a shell is required, use cmd.exe and take care of escaping everything correctly\n  // Note that `forceShell` is an hidden option used only in tests\n\n  if (parsed.options.forceShell || needsShell) {\n    // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`\n    // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument\n    // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,\n    // we need to double escape them\n    const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile); // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\\bar)\n    // This is necessary otherwise it will always fail with ENOENT in those cases\n\n    parsed.command = path.normalize(parsed.command); // Escape command & arguments\n\n    parsed.command = escape.command(parsed.command);\n    parsed.args = parsed.args.map(arg => escape.argument(arg, needsDoubleEscapeMetaChars));\n    const shellCommand = [parsed.command].concat(parsed.args).join(' ');\n    parsed.args = ['/d', '/s', '/c', \"\\\"\".concat(shellCommand, \"\\\"\")];\n    parsed.command = undefined || 'cmd.exe';\n    parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n  }\n\n  return parsed;\n}\n\nfunction parseShell(parsed) {\n  // If node supports the shell option, there's no need to mimic its behavior\n  if (supportsShellOption) {\n    return parsed;\n  } // Mimic node shell option\n  // See https://github.com/nodejs/node/blob/b9f6a2dc059a1062776133f3d4fd848c4da7d150/lib/child_process.js#L335\n\n\n  const shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n  if (isWin) {\n    parsed.command = typeof parsed.options.shell === 'string' ? parsed.options.shell : undefined || 'cmd.exe';\n    parsed.args = ['/d', '/s', '/c', \"\\\"\".concat(shellCommand, \"\\\"\")];\n    parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n  } else {\n    if (typeof parsed.options.shell === 'string') {\n      parsed.command = parsed.options.shell;\n    } else if (process.platform === 'android') {\n      parsed.command = '/system/bin/sh';\n    } else {\n      parsed.command = '/bin/sh';\n    }\n\n    parsed.args = ['-c', shellCommand];\n  }\n\n  return parsed;\n}\n\nfunction parse(command, args, options) {\n  // Normalize arguments, similar to nodejs\n  if (args && !Array.isArray(args)) {\n    options = args;\n    args = null;\n  }\n\n  args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n\n  options = Object.assign({}, options); // Clone object to avoid changing the original\n  // Build our parsed object\n\n  const parsed = {\n    command,\n    args,\n    options,\n    file: undefined,\n    original: {\n      command,\n      args\n    }\n  }; // Delegate further parsing to shell or non-shell\n\n  return options.shell ? parseShell(parsed) : parseNonShell(parsed);\n}\n\nmodule.exports = parse;"},"sourceMaps":null,"error":null,"hash":"05389fa9c1d3f73b20b7ddf722ef4ab4","cacheData":{"env":{}}}