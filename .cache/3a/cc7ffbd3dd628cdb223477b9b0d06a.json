{"id":"../node_modules/fs-extra/lib/copy/copy.js","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655165833},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fs-extra/package.json","includedInParent":true,"mtime":1594306880018},{"name":"graceful-fs","loc":{"line":3,"column":19},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fs-extra/lib/copy/copy.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/graceful-fs/graceful-fs.js"},{"name":"path","loc":{"line":4,"column":21},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fs-extra/lib/copy/copy.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/path-browserify/index.js"},{"name":"../mkdirs","loc":{"line":5,"column":23},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fs-extra/lib/copy/copy.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fs-extra/lib/mkdirs/index.js"},{"name":"../path-exists","loc":{"line":6,"column":27},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fs-extra/lib/copy/copy.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fs-extra/lib/path-exists/index.js"},{"name":"../util/utimes","loc":{"line":7,"column":23},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fs-extra/lib/copy/copy.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fs-extra/lib/util/utimes.js"},{"name":"process","parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/fs-extra/lib/copy/copy.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/process/browser.js"}],"generated":{"js":"var process = require(\"process\");\n'use strict';\n\nvar fs = require('graceful-fs');\n\nvar path = require('path');\n\nvar mkdirp = require('../mkdirs').mkdirs;\n\nvar pathExists = require('../path-exists').pathExists;\n\nvar utimes = require('../util/utimes').utimesMillis;\n\nvar notExist = Symbol('notExist');\n\nfunction copy(src, dest, opts, cb) {\n  if (typeof opts === 'function' && !cb) {\n    cb = opts;\n    opts = {};\n  } else if (typeof opts === 'function') {\n    opts = {\n      filter: opts\n    };\n  }\n\n  cb = cb || function () {};\n\n  opts = opts || {};\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now\n\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber\n  // Warn about using preserveTimestamps on 32-bit node\n\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(\"fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n    see https://github.com/jprichardson/node-fs-extra/issues/269\");\n  }\n\n  checkPaths(src, dest, function (err, destStat) {\n    if (err) return cb(err);\n    if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb);\n    return checkParentDir(destStat, src, dest, opts, cb);\n  });\n}\n\nfunction checkParentDir(destStat, src, dest, opts, cb) {\n  var destParent = path.dirname(dest);\n  pathExists(destParent, function (err, dirExists) {\n    if (err) return cb(err);\n    if (dirExists) return startCopy(destStat, src, dest, opts, cb);\n    mkdirp(destParent, function (err) {\n      if (err) return cb(err);\n      return startCopy(destStat, src, dest, opts, cb);\n    });\n  });\n}\n\nfunction handleFilter(onInclude, destStat, src, dest, opts, cb) {\n  Promise.resolve(opts.filter(src, dest)).then(function (include) {\n    if (include) {\n      if (destStat) return onInclude(destStat, src, dest, opts, cb);\n      return onInclude(src, dest, opts, cb);\n    }\n\n    return cb();\n  }, function (error) {\n    return cb(error);\n  });\n}\n\nfunction startCopy(destStat, src, dest, opts, cb) {\n  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb);\n  return getStats(destStat, src, dest, opts, cb);\n}\n\nfunction getStats(destStat, src, dest, opts, cb) {\n  var stat = opts.dereference ? fs.stat : fs.lstat;\n  stat(src, function (err, srcStat) {\n    if (err) return cb(err);\n    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb);else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb);else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb);\n  });\n}\n\nfunction onFile(srcStat, destStat, src, dest, opts, cb) {\n  if (destStat === notExist) return copyFile(srcStat, src, dest, opts, cb);\n  return mayCopyFile(srcStat, src, dest, opts, cb);\n}\n\nfunction mayCopyFile(srcStat, src, dest, opts, cb) {\n  if (opts.overwrite) {\n    fs.unlink(dest, function (err) {\n      if (err) return cb(err);\n      return copyFile(srcStat, src, dest, opts, cb);\n    });\n  } else if (opts.errorOnExist) {\n    return cb(new Error(\"'\".concat(dest, \"' already exists\")));\n  } else return cb();\n}\n\nfunction copyFile(srcStat, src, dest, opts, cb) {\n  if (typeof fs.copyFile === 'function') {\n    return fs.copyFile(src, dest, function (err) {\n      if (err) return cb(err);\n      return setDestModeAndTimestamps(srcStat, dest, opts, cb);\n    });\n  }\n\n  return copyFileFallback(srcStat, src, dest, opts, cb);\n}\n\nfunction copyFileFallback(srcStat, src, dest, opts, cb) {\n  var rs = fs.createReadStream(src);\n  rs.on('error', function (err) {\n    return cb(err);\n  }).once('open', function () {\n    var ws = fs.createWriteStream(dest, {\n      mode: srcStat.mode\n    });\n    ws.on('error', function (err) {\n      return cb(err);\n    }).on('open', function () {\n      return rs.pipe(ws);\n    }).once('close', function () {\n      return setDestModeAndTimestamps(srcStat, dest, opts, cb);\n    });\n  });\n}\n\nfunction setDestModeAndTimestamps(srcStat, dest, opts, cb) {\n  fs.chmod(dest, srcStat.mode, function (err) {\n    if (err) return cb(err);\n\n    if (opts.preserveTimestamps) {\n      return utimes(dest, srcStat.atime, srcStat.mtime, cb);\n    }\n\n    return cb();\n  });\n}\n\nfunction onDir(srcStat, destStat, src, dest, opts, cb) {\n  if (destStat === notExist) return mkDirAndCopy(srcStat, src, dest, opts, cb);\n\n  if (destStat && !destStat.isDirectory()) {\n    return cb(new Error(\"Cannot overwrite non-directory '\".concat(dest, \"' with directory '\").concat(src, \"'.\")));\n  }\n\n  return copyDir(src, dest, opts, cb);\n}\n\nfunction mkDirAndCopy(srcStat, src, dest, opts, cb) {\n  fs.mkdir(dest, function (err) {\n    if (err) return cb(err);\n    copyDir(src, dest, opts, function (err) {\n      if (err) return cb(err);\n      return fs.chmod(dest, srcStat.mode, cb);\n    });\n  });\n}\n\nfunction copyDir(src, dest, opts, cb) {\n  fs.readdir(src, function (err, items) {\n    if (err) return cb(err);\n    return copyDirItems(items, src, dest, opts, cb);\n  });\n}\n\nfunction copyDirItems(items, src, dest, opts, cb) {\n  var item = items.pop();\n  if (!item) return cb();\n  return copyDirItem(items, item, src, dest, opts, cb);\n}\n\nfunction copyDirItem(items, item, src, dest, opts, cb) {\n  var srcItem = path.join(src, item);\n  var destItem = path.join(dest, item);\n  checkPaths(srcItem, destItem, function (err, destStat) {\n    if (err) return cb(err);\n    startCopy(destStat, srcItem, destItem, opts, function (err) {\n      if (err) return cb(err);\n      return copyDirItems(items, src, dest, opts, cb);\n    });\n  });\n}\n\nfunction onLink(destStat, src, dest, opts, cb) {\n  fs.readlink(src, function (err, resolvedSrc) {\n    if (err) return cb(err);\n\n    if (opts.dereference) {\n      resolvedSrc = path.resolve(process.cwd(), resolvedSrc);\n    }\n\n    if (destStat === notExist) {\n      return fs.symlink(resolvedSrc, dest, cb);\n    } else {\n      fs.readlink(dest, function (err, resolvedDest) {\n        if (err) {\n          // dest exists and is a regular file or directory,\n          // Windows may throw UNKNOWN error. If dest already exists,\n          // fs throws error anyway, so no need to guard against it here.\n          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb);\n          return cb(err);\n        }\n\n        if (opts.dereference) {\n          resolvedDest = path.resolve(process.cwd(), resolvedDest);\n        }\n\n        if (isSrcSubdir(resolvedSrc, resolvedDest)) {\n          return cb(new Error(\"Cannot copy '\".concat(resolvedSrc, \"' to a subdirectory of itself, '\").concat(resolvedDest, \"'.\")));\n        } // do not copy if src is a subdir of dest since unlinking\n        // dest in this case would result in removing src contents\n        // and therefore a broken symlink would be created.\n\n\n        if (destStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {\n          return cb(new Error(\"Cannot overwrite '\".concat(resolvedDest, \"' with '\").concat(resolvedSrc, \"'.\")));\n        }\n\n        return copyLink(resolvedSrc, dest, cb);\n      });\n    }\n  });\n}\n\nfunction copyLink(resolvedSrc, dest, cb) {\n  fs.unlink(dest, function (err) {\n    if (err) return cb(err);\n    return fs.symlink(resolvedSrc, dest, cb);\n  });\n} // return true if dest is a subdir of src, otherwise false.\n\n\nfunction isSrcSubdir(src, dest) {\n  var srcArray = path.resolve(src).split(path.sep);\n  var destArray = path.resolve(dest).split(path.sep);\n  return srcArray.reduce(function (acc, current, i) {\n    return acc && destArray[i] === current;\n  }, true);\n}\n\nfunction checkStats(src, dest, cb) {\n  fs.stat(src, function (err, srcStat) {\n    if (err) return cb(err);\n    fs.stat(dest, function (err, destStat) {\n      if (err) {\n        if (err.code === 'ENOENT') return cb(null, {\n          srcStat,\n          destStat: notExist\n        });\n        return cb(err);\n      }\n\n      return cb(null, {\n        srcStat,\n        destStat\n      });\n    });\n  });\n}\n\nfunction checkPaths(src, dest, cb) {\n  checkStats(src, dest, function (err, stats) {\n    if (err) return cb(err);\n    var {\n      srcStat,\n      destStat\n    } = stats;\n\n    if (destStat.ino && destStat.ino === srcStat.ino) {\n      return cb(new Error('Source and destination must not be the same.'));\n    }\n\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(\"Cannot copy '\".concat(src, \"' to a subdirectory of itself, '\").concat(dest, \"'.\")));\n    }\n\n    return cb(null, destStat);\n  });\n}\n\nmodule.exports = copy;"},"sourceMaps":null,"error":null,"hash":"74a0db86db100b687daccda8271c9125","cacheData":{"env":{}}}