{"id":"../node_modules/html-webpack-plugin/index.js","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655291184},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/html-webpack-plugin/package.json","includedInParent":true,"mtime":1594306880054},{"name":"util.promisify","loc":{"line":11,"column":26},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/html-webpack-plugin/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/util.promisify/index.js"},{"name":"vm","loc":{"line":13,"column":19},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/html-webpack-plugin/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/vm-browserify/index.js"},{"name":"fs","loc":{"line":14,"column":19},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/html-webpack-plugin/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/parcel-bundler/src/builtins/_empty.js"},{"name":"lodash","loc":{"line":15,"column":18},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/html-webpack-plugin/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/lodash/lodash.js"},{"name":"path","loc":{"line":16,"column":21},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/html-webpack-plugin/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/path-browserify/index.js"},{"name":"loader-utils","loc":{"line":17,"column":28},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/html-webpack-plugin/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/loader-utils/lib/index.js"},{"name":"./lib/html-tags","loc":{"line":19,"column":63},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/html-webpack-plugin/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/html-webpack-plugin/lib/html-tags.js"},{"name":"./lib/compiler.js","loc":{"line":21,"column":30},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/html-webpack-plugin/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/html-webpack-plugin/lib/compiler.js"},{"name":"./lib/errors.js","loc":{"line":22,"column":28},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/html-webpack-plugin/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/html-webpack-plugin/lib/errors.js"},{"name":"./lib/chunksorter.js","loc":{"line":23,"column":28},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/html-webpack-plugin/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/html-webpack-plugin/lib/chunksorter.js"},{"name":"./lib/hooks.js","loc":{"line":24,"column":42},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/html-webpack-plugin/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/html-webpack-plugin/lib/hooks.js"},{"name":"html-minifier","loc":{"line":411,"column":16},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/html-webpack-plugin/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/html-minifier/src/htmlminifier.js"},{"name":"buffer","parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/html-webpack-plugin/index.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/buffer/index.js"}],"generated":{"js":"var __dirname = \"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/html-webpack-plugin\";\nvar Buffer = require(\"buffer\").Buffer;\nvar global = arguments[3];\n// @ts-check\n// Import types\n\n/* eslint-disable */\n/// <reference path=\"./typings.d.ts\" />\n\n/* eslint-enable */\n\n/** @typedef {import(\"webpack/lib/Compiler.js\")} WebpackCompiler */\n\n/** @typedef {import(\"webpack/lib/Compilation.js\")} WebpackCompilation */\n'use strict'; // use Polyfill for util.promisify in node versions < v8\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar promisify = require('util.promisify');\n\nvar vm = require('vm');\n\nvar fs = require('fs');\n\nvar _ = require('lodash');\n\nvar path = require('path');\n\nvar loaderUtils = require('loader-utils');\n\nvar _require = require('./lib/html-tags'),\n    createHtmlTagObject = _require.createHtmlTagObject,\n    htmlTagObjectToString = _require.htmlTagObjectToString;\n\nvar childCompiler = require('./lib/compiler.js');\n\nvar prettyError = require('./lib/errors.js');\n\nvar chunkSorter = require('./lib/chunksorter.js');\n\nvar getHtmlWebpackPluginHooks = require('./lib/hooks.js').getHtmlWebpackPluginHooks;\n\nvar fsStatAsync = promisify(fs.stat);\nvar fsReadFileAsync = promisify(fs.readFile);\n\nvar HtmlWebpackPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {Partial<HtmlWebpackPluginOptions>} [options]\n   */\n  function HtmlWebpackPlugin(options) {\n    _classCallCheck(this, HtmlWebpackPlugin);\n\n    /** @type {Partial<HtmlWebpackPluginOptions>} */\n    var userOptions = options || {}; // Default options\n\n    /** @type {HtmlWebpackPluginOptions} */\n\n    var defaultOptions = {\n      template: path.join(__dirname, 'default_index.ejs'),\n      templateContent: false,\n      templateParameters: templateParametersGenerator,\n      filename: 'index.html',\n      hash: false,\n      inject: true,\n      compile: true,\n      favicon: false,\n      minify: false,\n      cache: true,\n      showErrors: true,\n      chunks: 'all',\n      excludeChunks: [],\n      chunksSortMode: 'auto',\n      meta: {},\n      title: 'Webpack App',\n      xhtml: false\n    };\n    /** @type {HtmlWebpackPluginOptions} */\n\n    this.options = Object.assign(defaultOptions, userOptions); // Default metaOptions if no template is provided\n\n    if (!userOptions.template && this.options.templateContent === false && this.options.meta) {\n      var defaultMeta = {\n        // From https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag\n        viewport: 'width=device-width, initial-scale=1'\n      };\n      this.options.meta = Object.assign({}, this.options.meta, defaultMeta, userOptions.meta);\n    } // Instance variables to keep caching information\n    // for multiple builds\n\n\n    this.childCompilerHash = undefined;\n    /**\n     * @type {string | undefined}\n     */\n\n    this.childCompilationOutputName = undefined;\n    this.assetJson = undefined;\n    this.hash = undefined;\n    this.version = HtmlWebpackPlugin.version;\n  }\n  /**\n   * apply is called by the webpack main compiler during the start phase\n   * @param {WebpackCompiler} compiler\n   */\n\n\n  _createClass(HtmlWebpackPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var _this = this;\n\n      var self = this;\n      var isCompilationCached = false;\n      /** @type Promise<string> */\n\n      var compilationPromise;\n      this.options.template = this.getFullTemplatePath(this.options.template, compiler.context); // convert absolute filename into relative so that webpack can\n      // generate it at correct location\n\n      var filename = this.options.filename;\n\n      if (path.resolve(filename) === path.normalize(filename)) {\n        this.options.filename = path.relative(compiler.options.output.path, filename);\n      } // Clear the cache once a new HtmlWebpackPlugin is added\n\n\n      childCompiler.clearCache(compiler); // Register all HtmlWebpackPlugins instances at the child compiler\n\n      compiler.hooks.thisCompilation.tap('HtmlWebpackPlugin', function (compilation) {\n        // Clear the cache if the child compiler is outdated\n        if (childCompiler.hasOutDatedTemplateCache(compilation)) {\n          childCompiler.clearCache(compiler);\n        } // Add this instances template to the child compiler\n\n\n        childCompiler.addTemplateToCompiler(compiler, _this.options.template); // Add file dependencies of child compiler to parent compiler\n        // to keep them watched even if we get the result from the cache\n\n        compilation.hooks.additionalChunkAssets.tap('HtmlWebpackPlugin', function () {\n          var childCompilerDependencies = childCompiler.getFileDependencies(compiler);\n          childCompilerDependencies.forEach(function (fileDependency) {\n            compilation.compilationDependencies.add(fileDependency);\n          });\n        });\n      });\n      compiler.hooks.make.tapAsync('HtmlWebpackPlugin', function (compilation, callback) {\n        // Compile the template (queued)\n        compilationPromise = childCompiler.compileTemplate(self.options.template, self.options.filename, compilation).catch(function (err) {\n          compilation.errors.push(prettyError(err, compiler.context).toString());\n          return {\n            content: self.options.showErrors ? prettyError(err, compiler.context).toJsonHtml() : 'ERROR',\n            outputName: self.options.filename,\n            hash: ''\n          };\n        }).then(function (compilationResult) {\n          // If the compilation change didnt change the cache is valid\n          isCompilationCached = Boolean(compilationResult.hash) && self.childCompilerHash === compilationResult.hash;\n          self.childCompilerHash = compilationResult.hash;\n          self.childCompilationOutputName = compilationResult.outputName;\n          callback();\n          return compilationResult.content;\n        });\n      });\n      compiler.hooks.emit.tapAsync('HtmlWebpackPlugin',\n      /**\n       * Hook into the webpack emit phase\n       * @param {WebpackCompilation} compilation\n       * @param {() => void} callback\n      */\n      function (compilation, callback) {\n        // Get all entry point names for this html file\n        var entryNames = Array.from(compilation.entrypoints.keys());\n        var filteredEntryNames = self.filterChunks(entryNames, self.options.chunks, self.options.excludeChunks);\n        var sortedEntryNames = self.sortEntryChunks(filteredEntryNames, _this.options.chunksSortMode, compilation);\n        var childCompilationOutputName = self.childCompilationOutputName;\n\n        if (childCompilationOutputName === undefined) {\n          throw new Error('Did not receive child compilation result');\n        } // Turn the entry point names into file paths\n\n\n        var assets = self.htmlWebpackPluginAssets(compilation, childCompilationOutputName, sortedEntryNames); // If this is a hot update compilation, move on!\n        // This solves a problem where an `index.html` file is generated for hot-update js files\n        // It only happens in Webpack 2, where hot updates are emitted separately before the full bundle\n\n        if (self.isHotUpdateCompilation(assets)) {\n          return callback();\n        } // If the template and the assets did not change we don't have to emit the html\n\n\n        var assetJson = JSON.stringify(self.getAssetFiles(assets));\n\n        if (isCompilationCached && self.options.cache && assetJson === self.assetJson) {\n          return callback();\n        } else {\n          self.assetJson = assetJson;\n        } // The html-webpack plugin uses a object representation for the html-tags which will be injected\n        // to allow altering them more easily\n        // Just before they are converted a third-party-plugin author might change the order and content\n\n\n        var assetsPromise = _this.getFaviconPublicPath(_this.options.favicon, compilation, assets.publicPath).then(function (faviconPath) {\n          assets.favicon = faviconPath;\n          return getHtmlWebpackPluginHooks(compilation).beforeAssetTagGeneration.promise({\n            assets: assets,\n            outputName: childCompilationOutputName,\n            plugin: self\n          });\n        }); // Turn the js and css paths into grouped HtmlTagObjects\n\n\n        var assetTagGroupsPromise = assetsPromise // And allow third-party-plugin authors to reorder and change the assetTags before they are grouped\n        .then(function (_ref) {\n          var assets = _ref.assets;\n          return getHtmlWebpackPluginHooks(compilation).alterAssetTags.promise({\n            assetTags: {\n              scripts: self.generatedScriptTags(assets.js),\n              styles: self.generateStyleTags(assets.css),\n              meta: [].concat(_toConsumableArray(self.generatedMetaTags(self.options.meta)), _toConsumableArray(self.generateFaviconTags(assets.favicon)))\n            },\n            outputName: childCompilationOutputName,\n            plugin: self\n          });\n        }).then(function (_ref2) {\n          var assetTags = _ref2.assetTags;\n          // Inject scripts to body unless it set explictly to head\n          var scriptTarget = self.options.inject === 'head' ? 'head' : 'body'; // Group assets to `head` and `body` tag arrays\n\n          var assetGroups = _this.generateAssetGroups(assetTags, scriptTarget); // Allow third-party-plugin authors to reorder and change the assetTags once they are grouped\n\n\n          return getHtmlWebpackPluginHooks(compilation).alterAssetTagGroups.promise({\n            headTags: assetGroups.headTags,\n            bodyTags: assetGroups.bodyTags,\n            outputName: childCompilationOutputName,\n            plugin: self\n          });\n        }); // Turn the compiled tempalte into a nodejs function or into a nodejs string\n\n        var templateEvaluationPromise = compilationPromise.then(function (compiledTemplate) {\n          // Allow to use a custom function / string instead\n          if (self.options.templateContent !== false) {\n            return self.options.templateContent;\n          } // Once everything is compiled evaluate the html factory\n          // and replace it with its content\n\n\n          return self.evaluateCompilationResult(compilation, compiledTemplate);\n        });\n        var templateExectutionPromise = Promise.all([assetsPromise, assetTagGroupsPromise, templateEvaluationPromise]) // Execute the template\n        .then(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 3),\n              assetsHookResult = _ref4[0],\n              assetTags = _ref4[1],\n              compilationResult = _ref4[2];\n\n          return typeof compilationResult !== 'function' ? compilationResult : self.executeTemplate(compilationResult, assetsHookResult.assets, {\n            headTags: assetTags.headTags,\n            bodyTags: assetTags.bodyTags\n          }, compilation);\n        });\n        var injectedHtmlPromise = Promise.all([assetTagGroupsPromise, templateExectutionPromise]) // Allow plugins to change the html before assets are injected\n        .then(function (_ref5) {\n          var _ref6 = _slicedToArray(_ref5, 2),\n              assetTags = _ref6[0],\n              html = _ref6[1];\n\n          var pluginArgs = {\n            html,\n            headTags: assetTags.headTags,\n            bodyTags: assetTags.bodyTags,\n            plugin: self,\n            outputName: childCompilationOutputName\n          };\n          return getHtmlWebpackPluginHooks(compilation).afterTemplateExecution.promise(pluginArgs);\n        }).then(function (_ref7) {\n          var html = _ref7.html,\n              headTags = _ref7.headTags,\n              bodyTags = _ref7.bodyTags;\n          return self.postProcessHtml(html, assets, {\n            headTags,\n            bodyTags\n          });\n        });\n        var emitHtmlPromise = injectedHtmlPromise // Allow plugins to change the html after assets are injected\n        .then(function (html) {\n          var pluginArgs = {\n            html,\n            plugin: self,\n            outputName: childCompilationOutputName\n          };\n          return getHtmlWebpackPluginHooks(compilation).beforeEmit.promise(pluginArgs).then(function (result) {\n            return result.html;\n          });\n        }).catch(function (err) {\n          // In case anything went wrong the promise is resolved\n          // with the error message and an error is logged\n          compilation.errors.push(prettyError(err, compiler.context).toString()); // Prevent caching\n\n          self.hash = null;\n          return self.options.showErrors ? prettyError(err, compiler.context).toHtml() : 'ERROR';\n        }).then(function (html) {\n          // Allow to use [contenthash] as placeholder for the html-webpack-plugin name\n          // See also https://survivejs.com/webpack/optimizing/adding-hashes-to-filenames/\n          // From https://github.com/webpack-contrib/extract-text-webpack-plugin/blob/8de6558e33487e7606e7cd7cb2adc2cccafef272/src/index.js#L212-L214\n          var finalOutputName = childCompilationOutputName.replace(/\\[(?:(\\w+):)?contenthash(?::([a-z]+\\d*))?(?::(\\d+))?\\]/ig, function (_, hashType, digestType, maxLength) {\n            return loaderUtils.getHashDigest(Buffer.from(html, 'utf8'), hashType, digestType, parseInt(maxLength, 10));\n          }); // Add the evaluated html code to the webpack assets\n\n          compilation.assets[finalOutputName] = {\n            source: function source() {\n              return html;\n            },\n            size: function size() {\n              return html.length;\n            }\n          };\n          return finalOutputName;\n        }).then(function (finalOutputName) {\n          return getHtmlWebpackPluginHooks(compilation).afterEmit.promise({\n            outputName: finalOutputName,\n            plugin: self\n          }).catch(function (err) {\n            console.error(err);\n            return null;\n          }).then(function () {\n            return null;\n          });\n        }); // Once all files are added to the webpack compilation\n        // let the webpack compiler continue\n\n        emitHtmlPromise.then(function () {\n          callback();\n        });\n      });\n    }\n    /**\n     * Evaluates the child compilation result\n     * @param {WebpackCompilation} compilation\n     * @param {string} source\n     * @returns {Promise<string | (() => string | Promise<string>)>}\n     */\n\n  }, {\n    key: \"evaluateCompilationResult\",\n    value: function evaluateCompilationResult(compilation, source) {\n      if (!source) {\n        return Promise.reject('The child compilation didn\\'t provide a result');\n      } // The LibraryTemplatePlugin stores the template result in a local variable.\n      // To extract the result during the evaluation this part has to be removed.\n\n\n      source = source.replace('var HTML_WEBPACK_PLUGIN_RESULT =', '');\n      var template = this.options.template.replace(/^.+!/, '').replace(/\\?.+$/, '');\n      var vmContext = vm.createContext(_.extend({\n        HTML_WEBPACK_PLUGIN: true,\n        require: require\n      }, global));\n      var vmScript = new vm.Script(source, {\n        filename: template\n      }); // Evaluate code and cast to string\n\n      var newSource;\n\n      try {\n        newSource = vmScript.runInContext(vmContext);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n\n      if (typeof newSource === 'object' && newSource.__esModule && newSource.default) {\n        newSource = newSource.default;\n      }\n\n      return typeof newSource === 'string' || typeof newSource === 'function' ? Promise.resolve(newSource) : Promise.reject('The loader \"' + this.options.template + '\" didn\\'t return html.');\n    }\n    /**\n     * Generate the template parameters for the template function\n     * @param {WebpackCompilation} compilation\n     * @param {{\n        publicPath: string,\n        js: Array<string>,\n        css: Array<string>,\n        manifest?: string,\n        favicon?: string\n      }} assets\n     * @param {{\n         headTags: HtmlTagObject[],\n         bodyTags: HtmlTagObject[]\n       }} assetTags\n     * @returns {{[key: any]: any}}\n     */\n\n  }, {\n    key: \"getTemplateParameters\",\n    value: function getTemplateParameters(compilation, assets, assetTags) {\n      if (this.options.templateParameters === false) {\n        return {};\n      }\n\n      if (typeof this.options.templateParameters === 'function') {\n        return this.options.templateParameters(compilation, assets, assetTags, this.options);\n      }\n\n      if (typeof this.options.templateParameters === 'object') {\n        return this.options.templateParameters;\n      }\n\n      throw new Error('templateParameters has to be either a function or an object');\n    }\n    /**\n     * This function renders the actual html by executing the template function\n     *\n     * @param {(templatePArameters) => string | Promise<string>} templateFunction\n     * @param {{\n        publicPath: string,\n        js: Array<string>,\n        css: Array<string>,\n        manifest?: string,\n        favicon?: string\n      }} assets\n     * @param {{\n         headTags: HtmlTagObject[],\n         bodyTags: HtmlTagObject[]\n       }} assetTags\n     * @param {WebpackCompilation} compilation\n     *\n     * @returns Promise<string>\n     */\n\n  }, {\n    key: \"executeTemplate\",\n    value: function executeTemplate(templateFunction, assets, assetTags, compilation) {\n      // Template processing\n      var templateParams = this.getTemplateParameters(compilation, assets, assetTags);\n      /** @type {string|Promise<string>} */\n\n      var html = '';\n\n      try {\n        html = templateFunction(templateParams);\n      } catch (e) {\n        compilation.errors.push(new Error('Template execution failed: ' + e));\n        return Promise.reject(e);\n      } // If html is a promise return the promise\n      // If html is a string turn it into a promise\n\n\n      return Promise.resolve().then(function () {\n        return html;\n      });\n    }\n    /**\n     * Html Post processing\n     *\n     * @param {any} html\n     * The input html\n     * @param {any} assets\n     * @param {{\n         headTags: HtmlTagObject[],\n         bodyTags: HtmlTagObject[]\n       }} assetTags\n     * The asset tags to inject\n     *\n     * @returns {Promise<string>}\n     */\n\n  }, {\n    key: \"postProcessHtml\",\n    value: function postProcessHtml(html, assets, assetTags) {\n      if (typeof html !== 'string') {\n        return Promise.reject('Expected html to be a string but got ' + JSON.stringify(html));\n      }\n\n      var htmlAfterInjection = this.options.inject ? this.injectAssetsIntoHtml(html, assets, assetTags) : html;\n      var htmlAfterMinification = this.options.minify ? require('html-minifier').minify(htmlAfterInjection, this.options.minify === true ? {} : this.options.minify) : htmlAfterInjection;\n      return Promise.resolve(htmlAfterMinification);\n    }\n    /*\n     * Pushes the content of the given filename to the compilation assets\n     * @param {string} filename\n     * @param {WebpackCompilation} compilation\n     *\n     * @returns {string} file basename\n     */\n\n  }, {\n    key: \"addFileToAssets\",\n    value: function addFileToAssets(filename, compilation) {\n      filename = path.resolve(compilation.compiler.context, filename);\n      return Promise.all([fsStatAsync(filename), fsReadFileAsync(filename)]).then(function (_ref8) {\n        var _ref9 = _slicedToArray(_ref8, 2),\n            size = _ref9[0],\n            source = _ref9[1];\n\n        return {\n          size,\n          source\n        };\n      }).catch(function () {\n        return Promise.reject(new Error('HtmlWebpackPlugin: could not load file ' + filename));\n      }).then(function (results) {\n        var basename = path.basename(filename);\n        compilation.fileDependencies.add(filename);\n        compilation.assets[basename] = {\n          source: function source() {\n            return results.source;\n          },\n          size: function size() {\n            return results.size.size;\n          }\n        };\n        return basename;\n      });\n    }\n    /**\n     * Helper to sort chunks\n     * @param {string[]} entryNames\n     * @param {string|((entryNameA: string, entryNameB: string) => number)} sortMode\n     * @param {WebpackCompilation} compilation\n     */\n\n  }, {\n    key: \"sortEntryChunks\",\n    value: function sortEntryChunks(entryNames, sortMode, compilation) {\n      // Custom function\n      if (typeof sortMode === 'function') {\n        return entryNames.sort(sortMode);\n      } // Check if the given sort mode is a valid chunkSorter sort mode\n\n\n      if (typeof chunkSorter[sortMode] !== 'undefined') {\n        return chunkSorter[sortMode](entryNames, compilation, this.options);\n      }\n\n      throw new Error('\"' + sortMode + '\" is not a valid chunk sort mode');\n    }\n    /**\n     * Return all chunks from the compilation result which match the exclude and include filters\n     * @param {any} chunks\n     * @param {string[]|'all'} includedChunks\n     * @param {string[]} excludedChunks\n     */\n\n  }, {\n    key: \"filterChunks\",\n    value: function filterChunks(chunks, includedChunks, excludedChunks) {\n      return chunks.filter(function (chunkName) {\n        // Skip if the chunks should be filtered and the given chunk was not added explicity\n        if (Array.isArray(includedChunks) && includedChunks.indexOf(chunkName) === -1) {\n          return false;\n        } // Skip if the chunks should be filtered and the given chunk was excluded explicity\n\n\n        if (Array.isArray(excludedChunks) && excludedChunks.indexOf(chunkName) !== -1) {\n          return false;\n        } // Add otherwise\n\n\n        return true;\n      });\n    }\n    /**\n     * Check if the given asset object consists only of hot-update.js files\n     *\n     * @param {{\n        publicPath: string,\n        js: Array<string>,\n        css: Array<string>,\n        manifest?: string,\n        favicon?: string\n      }} assets\n     */\n\n  }, {\n    key: \"isHotUpdateCompilation\",\n    value: function isHotUpdateCompilation(assets) {\n      return assets.js.length && assets.js.every(function (assetPath) {\n        return /\\.hot-update\\.js$/.test(assetPath);\n      });\n    }\n    /**\n     * The htmlWebpackPluginAssets extracts the asset information of a webpack compilation\n     * for all given entry names\n     * @param {WebpackCompilation} compilation\n     * @param {string[]} entryNames\n     * @returns {{\n        publicPath: string,\n        js: Array<string>,\n        css: Array<string>,\n        manifest?: string,\n        favicon?: string\n      }}\n     */\n\n  }, {\n    key: \"htmlWebpackPluginAssets\",\n    value: function htmlWebpackPluginAssets(compilation, childCompilationOutputName, entryNames) {\n      var _this2 = this;\n\n      var compilationHash = compilation.hash;\n      /**\n       * @type {string} the configured public path to the asset root\n       * if a publicPath is set in the current webpack config use it otherwise\n       * fallback to a realtive path\n       */\n\n      var publicPath = typeof compilation.options.output.publicPath !== 'undefined' // If a hard coded public path exists use it\n      ? compilation.mainTemplate.getPublicPath({\n        hash: compilationHash\n      }) // If no public path was set get a relative url path\n      : path.relative(path.resolve(compilation.options.output.path, path.dirname(childCompilationOutputName)), compilation.options.output.path).split(path.sep).join('/');\n\n      if (publicPath.length && publicPath.substr(-1, 1) !== '/') {\n        publicPath += '/';\n      }\n      /**\n       * @type {{\n          publicPath: string,\n          js: Array<string>,\n          css: Array<string>,\n          manifest?: string,\n          favicon?: string\n        }}\n       */\n\n\n      var assets = {\n        // The public path\n        publicPath: publicPath,\n        // Will contain all js files\n        js: [],\n        // Will contain all css files\n        css: [],\n        // Will contain the html5 appcache manifest files if it exists\n        manifest: Object.keys(compilation.assets).find(function (assetFile) {\n          return path.extname(assetFile) === '.appcache';\n        }),\n        // Favicon\n        favicon: undefined\n      }; // Append a hash for cache busting\n\n      if (this.options.hash && assets.manifest) {\n        assets.manifest = this.appendHash(assets.manifest, compilationHash);\n      } // Extract paths to .js and .css files from the current compilation\n\n\n      var entryPointPublicPathMap = {};\n      var extensionRegexp = /\\.(css|js)(\\?|$)/;\n\n      for (var i = 0; i < entryNames.length; i++) {\n        var entryName = entryNames[i];\n        var entryPointFiles = compilation.entrypoints.get(entryName).getFiles(); // Prepend the publicPath and append the hash depending on the\n        // webpack.output.publicPath and hashOptions\n        // E.g. bundle.js -> /bundle.js?hash\n\n        var entryPointPublicPaths = entryPointFiles.map(function (chunkFile) {\n          var entryPointPublicPath = publicPath + chunkFile;\n          return _this2.options.hash ? _this2.appendHash(entryPointPublicPath, compilationHash) : entryPointPublicPath;\n        });\n        entryPointPublicPaths.forEach(function (entryPointPublicPath) {\n          var extMatch = extensionRegexp.exec(entryPointPublicPath); // Skip if the public path is not a .css or .js file\n\n          if (!extMatch) {\n            return;\n          } // Skip if this file is already known\n          // (e.g. because of common chunk optimizations)\n\n\n          if (entryPointPublicPathMap[entryPointPublicPath]) {\n            return;\n          }\n\n          entryPointPublicPathMap[entryPointPublicPath] = true; // ext will contain .js or .css\n\n          var ext = extMatch[1];\n          assets[ext].push(entryPointPublicPath);\n        });\n      }\n\n      return assets;\n    }\n    /**\n     * Converts a favicon file from disk to a webpack ressource\n     * and returns the url to the ressource\n     *\n     * @param {string|false} faviconFilePath\n     * @param {WebpackCompilation} compilation\n     * @parma {string} publicPath\n     * @returns {Promise<string|undefined>}\n     */\n\n  }, {\n    key: \"getFaviconPublicPath\",\n    value: function getFaviconPublicPath(faviconFilePath, compilation, publicPath) {\n      var _this3 = this;\n\n      if (!faviconFilePath) {\n        return Promise.resolve(undefined);\n      }\n\n      return this.addFileToAssets(faviconFilePath, compilation).then(function (faviconName) {\n        var faviconPath = publicPath + faviconName;\n\n        if (_this3.options.hash) {\n          return _this3.appendHash(faviconPath, compilation.hash);\n        }\n\n        return faviconPath;\n      });\n    }\n    /**\n     * Generate meta tags\n     * @returns {HtmlTagObject[]}\n     */\n\n  }, {\n    key: \"getMetaTags\",\n    value: function getMetaTags() {\n      var metaOptions = this.options.meta;\n\n      if (metaOptions === false) {\n        return [];\n      } // Make tags self-closing in case of xhtml\n      // Turn { \"viewport\" : \"width=500, initial-scale=1\" } into\n      // [{ name:\"viewport\" content:\"width=500, initial-scale=1\" }]\n\n\n      var metaTagAttributeObjects = Object.keys(metaOptions).map(function (metaName) {\n        var metaTagContent = metaOptions[metaName];\n        return typeof metaTagContent === 'string' ? {\n          name: metaName,\n          content: metaTagContent\n        } : metaTagContent;\n      }).filter(function (attribute) {\n        return attribute !== false;\n      }); // Turn [{ name:\"viewport\" content:\"width=500, initial-scale=1\" }] into\n      // the html-webpack-plugin tag structure\n\n      return metaTagAttributeObjects.map(function (metaTagAttributes) {\n        if (metaTagAttributes === false) {\n          throw new Error('Invalid meta tag');\n        }\n\n        return {\n          tagName: 'meta',\n          voidTag: true,\n          attributes: metaTagAttributes\n        };\n      });\n    }\n    /**\n     * Generate all tags script for the given file paths\n     * @param {Array<string>} jsAssets\n     * @returns {Array<HtmlTagObject>}\n     */\n\n  }, {\n    key: \"generatedScriptTags\",\n    value: function generatedScriptTags(jsAssets) {\n      return jsAssets.map(function (scriptAsset) {\n        return {\n          tagName: 'script',\n          voidTag: false,\n          attributes: {\n            src: scriptAsset\n          }\n        };\n      });\n    }\n    /**\n     * Generate all style tags for the given file paths\n     * @param {Array<string>} cssAssets\n     * @returns {Array<HtmlTagObject>}\n     */\n\n  }, {\n    key: \"generateStyleTags\",\n    value: function generateStyleTags(cssAssets) {\n      return cssAssets.map(function (styleAsset) {\n        return {\n          tagName: 'link',\n          voidTag: true,\n          attributes: {\n            href: styleAsset,\n            rel: 'stylesheet'\n          }\n        };\n      });\n    }\n    /**\n     * Generate all meta tags for the given meta configuration\n     * @param {false | {\n              [name: string]: string|false // name content pair e.g. {viewport: 'width=device-width, initial-scale=1, shrink-to-fit=no'}`\n              | {[attributeName: string]: string|boolean} // custom properties e.g. { name:\"viewport\" content:\"width=500, initial-scale=1\" }\n          }} metaOptions\n    * @returns {Array<HtmlTagObject>}\n    */\n\n  }, {\n    key: \"generatedMetaTags\",\n    value: function generatedMetaTags(metaOptions) {\n      if (metaOptions === false) {\n        return [];\n      } // Make tags self-closing in case of xhtml\n      // Turn { \"viewport\" : \"width=500, initial-scale=1\" } into\n      // [{ name:\"viewport\" content:\"width=500, initial-scale=1\" }]\n\n\n      var metaTagAttributeObjects = Object.keys(metaOptions).map(function (metaName) {\n        var metaTagContent = metaOptions[metaName];\n        return typeof metaTagContent === 'string' ? {\n          name: metaName,\n          content: metaTagContent\n        } : metaTagContent;\n      }).filter(function (attribute) {\n        return attribute !== false;\n      }); // Turn [{ name:\"viewport\" content:\"width=500, initial-scale=1\" }] into\n      // the html-webpack-plugin tag structure\n\n      return metaTagAttributeObjects.map(function (metaTagAttributes) {\n        if (metaTagAttributes === false) {\n          throw new Error('Invalid meta tag');\n        }\n\n        return {\n          tagName: 'meta',\n          voidTag: true,\n          attributes: metaTagAttributes\n        };\n      });\n    }\n    /**\n     * Generate a favicon tag for the given file path\n     * @param {string| undefined} faviconPath\n     * @returns {Array<HtmlTagObject>}\n     */\n\n  }, {\n    key: \"generateFaviconTags\",\n    value: function generateFaviconTags(faviconPath) {\n      if (!faviconPath) {\n        return [];\n      }\n\n      return [{\n        tagName: 'link',\n        voidTag: true,\n        attributes: {\n          rel: 'shortcut icon',\n          href: faviconPath\n        }\n      }];\n    }\n    /**\n     * Group assets to head and bottom tags\n     *\n     * @param {{\n        scripts: Array<HtmlTagObject>;\n        styles: Array<HtmlTagObject>;\n        meta: Array<HtmlTagObject>;\n      }} assetTags\n    * @param {\"body\" | \"head\"} scriptTarget\n    * @returns {{\n        headTags: Array<HtmlTagObject>;\n        bodyTags: Array<HtmlTagObject>;\n      }}\n    */\n\n  }, {\n    key: \"generateAssetGroups\",\n    value: function generateAssetGroups(assetTags, scriptTarget) {\n      /** @type {{ headTags: Array<HtmlTagObject>; bodyTags: Array<HtmlTagObject>; }} */\n      var result = {\n        headTags: [].concat(_toConsumableArray(assetTags.meta), _toConsumableArray(assetTags.styles)),\n        bodyTags: []\n      }; // Add script tags to head or body depending on\n      // the htmlPluginOptions\n\n      if (scriptTarget === 'body') {\n        var _result$bodyTags;\n\n        (_result$bodyTags = result.bodyTags).push.apply(_result$bodyTags, _toConsumableArray(assetTags.scripts));\n      } else {\n        var _result$headTags;\n\n        (_result$headTags = result.headTags).push.apply(_result$headTags, _toConsumableArray(assetTags.scripts));\n      }\n\n      return result;\n    }\n    /**\n     * Injects the assets into the given html string\n     *\n     * @param {string} html\n     * The input html\n     * @param {any} assets\n     * @param {{\n         headTags: HtmlTagObject[],\n         bodyTags: HtmlTagObject[]\n       }} assetTags\n     * The asset tags to inject\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: \"injectAssetsIntoHtml\",\n    value: function injectAssetsIntoHtml(html, assets, assetTags) {\n      var _this4 = this;\n\n      var htmlRegExp = /(<html[^>]*>)/i;\n      var headRegExp = /(<\\/head\\s*>)/i;\n      var bodyRegExp = /(<\\/body\\s*>)/i;\n      var body = assetTags.bodyTags.map(function (assetTagObject) {\n        return htmlTagObjectToString(assetTagObject, _this4.options.xhtml);\n      });\n      var head = assetTags.headTags.map(function (assetTagObject) {\n        return htmlTagObjectToString(assetTagObject, _this4.options.xhtml);\n      });\n\n      if (body.length) {\n        if (bodyRegExp.test(html)) {\n          // Append assets to body element\n          html = html.replace(bodyRegExp, function (match) {\n            return body.join('') + match;\n          });\n        } else {\n          // Append scripts to the end of the file if no <body> element exists:\n          html += body.join('');\n        }\n      }\n\n      if (head.length) {\n        // Create a head tag if none exists\n        if (!headRegExp.test(html)) {\n          if (!htmlRegExp.test(html)) {\n            html = '<head></head>' + html;\n          } else {\n            html = html.replace(htmlRegExp, function (match) {\n              return match + '<head></head>';\n            });\n          }\n        } // Append assets to head element\n\n\n        html = html.replace(headRegExp, function (match) {\n          return head.join('') + match;\n        });\n      } // Inject manifest into the opening html tag\n\n\n      if (assets.manifest) {\n        html = html.replace(/(<html[^>]*)(>)/i, function (match, start, end) {\n          // Append the manifest only if no manifest was specified\n          if (/\\smanifest\\s*=/.test(match)) {\n            return match;\n          }\n\n          return start + ' manifest=\"' + assets.manifest + '\"' + end;\n        });\n      }\n\n      return html;\n    }\n    /**\n     * Appends a cache busting hash to the query string of the url\n     * E.g. http://localhost:8080/ -> http://localhost:8080/?50c9096ba6183fd728eeb065a26ec175\n     * @param {string} url\n     * @param {string} hash\n     */\n\n  }, {\n    key: \"appendHash\",\n    value: function appendHash(url, hash) {\n      if (!url) {\n        return url;\n      }\n\n      return url + (url.indexOf('?') === -1 ? '?' : '&') + hash;\n    }\n    /**\n     * Helper to return the absolute template path with a fallback loader\n     * @param {string} template\n     * The path to the tempalate e.g. './index.html'\n     * @param {string} context\n     * The webpack base resolution path for relative paths e.g. process.cwd()\n     */\n\n  }, {\n    key: \"getFullTemplatePath\",\n    value: function getFullTemplatePath(template, context) {\n      // If the template doesn't use a loader use the lodash template loader\n      if (template.indexOf('!') === -1) {\n        template = require.resolve('./lib/loader.js') + '!' + path.resolve(context, template);\n      } // Resolve template path\n\n\n      return template.replace(/([!])([^/\\\\][^!?]+|[^/\\\\!?])($|\\?[^!?\\n]+$)/, function (match, prefix, filepath, postfix) {\n        return prefix + path.resolve(filepath) + postfix;\n      });\n    }\n    /**\n     * Helper to return a sorted unique array of all asset files out of the\n     * asset object\n     */\n\n  }, {\n    key: \"getAssetFiles\",\n    value: function getAssetFiles(assets) {\n      var files = _.uniq(Object.keys(assets).filter(function (assetType) {\n        return assetType !== 'chunks' && assets[assetType];\n      }).reduce(function (files, assetType) {\n        return files.concat(assets[assetType]);\n      }, []));\n\n      files.sort();\n      return files;\n    }\n  }]);\n\n  return HtmlWebpackPlugin;\n}();\n/**\n * The default for options.templateParameter\n * Generate the template parameters\n *\n * Generate the template parameters for the template function\n * @param {WebpackCompilation} compilation\n * @param {{\n   publicPath: string,\n   js: Array<string>,\n   css: Array<string>,\n   manifest?: string,\n   favicon?: string\n }} assets\n * @param {{\n     headTags: HtmlTagObject[],\n     bodyTags: HtmlTagObject[]\n   }} assetTags\n * @param {HtmlWebpackPluginOptions} options\n * @returns {HtmlWebpackPluginTemplateParameter}\n */\n\n\nfunction templateParametersGenerator(compilation, assets, assetTags, options) {\n  var xhtml = options.xhtml;\n\n  assetTags.headTags.toString = function () {\n    return this.map(function (assetTagObject) {\n      return htmlTagObjectToString(assetTagObject, xhtml);\n    }).join('');\n  };\n\n  assetTags.bodyTags.toString = function () {\n    return this.map(function (assetTagObject) {\n      return htmlTagObjectToString(assetTagObject, xhtml);\n    }).join('');\n  };\n\n  return {\n    compilation: compilation,\n    webpackConfig: compilation.options,\n    htmlWebpackPlugin: {\n      tags: assetTags,\n      files: assets,\n      options: options\n    }\n  };\n} // Statics:\n\n/**\n * The major version number of this plugin\n */\n\n\nHtmlWebpackPlugin.version = 4;\n/**\n * A static helper to get the hooks for this plugin\n *\n * Usage: HtmlWebpackPlugin.getHooks(compilation).HOOK_NAME.tapAsync('YourPluginName', () => { ... });\n */\n\nHtmlWebpackPlugin.getHooks = getHtmlWebpackPluginHooks;\nHtmlWebpackPlugin.createHtmlTagObject = createHtmlTagObject;\nmodule.exports = HtmlWebpackPlugin;"},"sourceMaps":null,"error":null,"hash":"578e748ce992983c41d4e0d723bf385c","cacheData":{"env":{}}}