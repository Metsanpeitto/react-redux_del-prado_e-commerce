{"id":"../node_modules/webpack/node_modules/@webassemblyjs/wast-parser/esm/tokenizer.js","dependencies":[{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/package.json","includedInParent":true,"mtime":1594655165833},{"name":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/@webassemblyjs/wast-parser/package.json","includedInParent":true,"mtime":1594578778157},{"name":"@webassemblyjs/helper-fsm","loc":{"line":1,"column":36},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/@webassemblyjs/wast-parser/esm/tokenizer.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/@webassemblyjs/helper-fsm/esm/index.js"},{"name":"@webassemblyjs/helper-code-frame","loc":{"line":2,"column":36},"parent":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/@webassemblyjs/wast-parser/esm/tokenizer.js","resolved":"/home/jarri/Desktop/lenovo2020/projects-web/eCommerce/template-store1/node_modules/webpack/node_modules/@webassemblyjs/helper-code-frame/esm/index.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tokenize = tokenize;\nexports.tokens = exports.keywords = void 0;\n\nvar _helperFsm = require(\"@webassemblyjs/helper-fsm\");\n\nvar _helperCodeFrame = require(\"@webassemblyjs/helper-code-frame\");\n\n// eslint-disable-next-line\nfunction getCodeFrame(source, line, column) {\n  var loc = {\n    start: {\n      line: line,\n      column: column\n    }\n  };\n  return \"\\n\" + (0, _helperCodeFrame.codeFrameFromSource)(source, loc) + \"\\n\";\n}\n\nvar WHITESPACE = /\\s/;\nvar PARENS = /\\(|\\)/;\nvar LETTERS = /[a-z0-9_/]/i;\nvar idchar = /[a-z0-9!#$%&*+./:<=>?@\\\\[\\]^_`|~-]/i;\nvar valtypes = [\"i32\", \"i64\", \"f32\", \"f64\"];\nvar NUMBERS = /[0-9|.|_]/;\nvar NUMBER_KEYWORDS = /nan|inf/;\n\nfunction isNewLine(char) {\n  return char.charCodeAt(0) === 10 || char.charCodeAt(0) === 13;\n}\n\nfunction Token(type, value, start, end) {\n  var opts = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var token = {\n    type: type,\n    value: value,\n    loc: {\n      start: start,\n      end: end\n    }\n  };\n\n  if (Object.keys(opts).length > 0) {\n    // $FlowIgnore\n    token[\"opts\"] = opts;\n  }\n\n  return token;\n}\n\nvar tokenTypes = {\n  openParen: \"openParen\",\n  closeParen: \"closeParen\",\n  number: \"number\",\n  string: \"string\",\n  name: \"name\",\n  identifier: \"identifier\",\n  valtype: \"valtype\",\n  dot: \"dot\",\n  comment: \"comment\",\n  equal: \"equal\",\n  keyword: \"keyword\"\n};\nvar keywords = {\n  module: \"module\",\n  func: \"func\",\n  param: \"param\",\n  result: \"result\",\n  export: \"export\",\n  loop: \"loop\",\n  block: \"block\",\n  if: \"if\",\n  then: \"then\",\n  else: \"else\",\n  call: \"call\",\n  call_indirect: \"call_indirect\",\n  import: \"import\",\n  memory: \"memory\",\n  table: \"table\",\n  global: \"global\",\n  anyfunc: \"anyfunc\",\n  mut: \"mut\",\n  data: \"data\",\n  type: \"type\",\n  elem: \"elem\",\n  start: \"start\",\n  offset: \"offset\"\n};\nexports.keywords = keywords;\nvar NUMERIC_SEPARATOR = \"_\";\n/**\n * Build the FSM for number literals\n */\n\nvar numberLiteralFSM = new _helperFsm.FSM({\n  START: [(0, _helperFsm.makeTransition)(/-|\\+/, \"AFTER_SIGN\"), (0, _helperFsm.makeTransition)(/nan:0x/, \"NAN_HEX\", {\n    n: 6\n  }), (0, _helperFsm.makeTransition)(/nan|inf/, \"STOP\", {\n    n: 3\n  }), (0, _helperFsm.makeTransition)(/0x/, \"HEX\", {\n    n: 2\n  }), (0, _helperFsm.makeTransition)(/[0-9]/, \"DEC\"), (0, _helperFsm.makeTransition)(/\\./, \"DEC_FRAC\")],\n  AFTER_SIGN: [(0, _helperFsm.makeTransition)(/nan:0x/, \"NAN_HEX\", {\n    n: 6\n  }), (0, _helperFsm.makeTransition)(/nan|inf/, \"STOP\", {\n    n: 3\n  }), (0, _helperFsm.makeTransition)(/0x/, \"HEX\", {\n    n: 2\n  }), (0, _helperFsm.makeTransition)(/[0-9]/, \"DEC\"), (0, _helperFsm.makeTransition)(/\\./, \"DEC_FRAC\")],\n  DEC_FRAC: [(0, _helperFsm.makeTransition)(/[0-9]/, \"DEC_FRAC\", {\n    allowedSeparator: NUMERIC_SEPARATOR\n  }), (0, _helperFsm.makeTransition)(/e|E/, \"DEC_SIGNED_EXP\")],\n  DEC: [(0, _helperFsm.makeTransition)(/[0-9]/, \"DEC\", {\n    allowedSeparator: NUMERIC_SEPARATOR\n  }), (0, _helperFsm.makeTransition)(/\\./, \"DEC_FRAC\"), (0, _helperFsm.makeTransition)(/e|E/, \"DEC_SIGNED_EXP\")],\n  DEC_SIGNED_EXP: [(0, _helperFsm.makeTransition)(/\\+|-/, \"DEC_EXP\"), (0, _helperFsm.makeTransition)(/[0-9]/, \"DEC_EXP\")],\n  DEC_EXP: [(0, _helperFsm.makeTransition)(/[0-9]/, \"DEC_EXP\", {\n    allowedSeparator: NUMERIC_SEPARATOR\n  })],\n  HEX: [(0, _helperFsm.makeTransition)(/[0-9|A-F|a-f]/, \"HEX\", {\n    allowedSeparator: NUMERIC_SEPARATOR\n  }), (0, _helperFsm.makeTransition)(/\\./, \"HEX_FRAC\"), (0, _helperFsm.makeTransition)(/p|P/, \"HEX_SIGNED_EXP\")],\n  HEX_FRAC: [(0, _helperFsm.makeTransition)(/[0-9|A-F|a-f]/, \"HEX_FRAC\", {\n    allowedSeparator: NUMERIC_SEPARATOR\n  }), (0, _helperFsm.makeTransition)(/p|P|/, \"HEX_SIGNED_EXP\")],\n  HEX_SIGNED_EXP: [(0, _helperFsm.makeTransition)(/[0-9|+|-]/, \"HEX_EXP\")],\n  HEX_EXP: [(0, _helperFsm.makeTransition)(/[0-9]/, \"HEX_EXP\", {\n    allowedSeparator: NUMERIC_SEPARATOR\n  })],\n  NAN_HEX: [(0, _helperFsm.makeTransition)(/[0-9|A-F|a-f]/, \"NAN_HEX\", {\n    allowedSeparator: NUMERIC_SEPARATOR\n  })],\n  STOP: []\n}, \"START\", \"STOP\");\n\nfunction tokenize(input) {\n  var current = 0;\n  var char = input[current]; // Used by SourceLocation\n\n  var column = 1;\n  var line = 1;\n  var tokens = [];\n  /**\n   * Creates a pushToken function for a given type\n   */\n\n  function pushToken(type) {\n    return function (v) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var startColumn = opts.startColumn || column - String(v).length;\n      delete opts.startColumn;\n      var endColumn = opts.endColumn || startColumn + String(v).length - 1;\n      delete opts.endColumn;\n      var start = {\n        line: line,\n        column: startColumn\n      };\n      var end = {\n        line: line,\n        column: endColumn\n      };\n      tokens.push(Token(type, v, start, end, opts));\n    };\n  }\n  /**\n   * Functions to save newly encountered tokens\n   */\n\n\n  var pushCloseParenToken = pushToken(tokenTypes.closeParen);\n  var pushOpenParenToken = pushToken(tokenTypes.openParen);\n  var pushNumberToken = pushToken(tokenTypes.number);\n  var pushValtypeToken = pushToken(tokenTypes.valtype);\n  var pushNameToken = pushToken(tokenTypes.name);\n  var pushIdentifierToken = pushToken(tokenTypes.identifier);\n  var pushKeywordToken = pushToken(tokenTypes.keyword);\n  var pushDotToken = pushToken(tokenTypes.dot);\n  var pushStringToken = pushToken(tokenTypes.string);\n  var pushCommentToken = pushToken(tokenTypes.comment);\n  var pushEqualToken = pushToken(tokenTypes.equal);\n  /**\n   * Can be used to look at the next character(s).\n   *\n   * The default behavior `lookahead()` simply returns the next character without consuming it.\n   * Letters are always returned in lowercase.\n   *\n   * @param {number} length How many characters to query. Default = 1\n   * @param {number} offset How many characters to skip forward from current one. Default = 1\n   *\n   */\n\n  function lookahead() {\n    var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    return input.substring(current + offset, current + offset + length).toLowerCase();\n  }\n  /**\n   * Advances the cursor in the input by a certain amount\n   *\n   * @param {number} amount How many characters to consume. Default = 1\n   */\n\n\n  function eatCharacter() {\n    var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    column += amount;\n    current += amount;\n    char = input[current];\n  }\n\n  while (current < input.length) {\n    // ;;\n    if (char === \";\" && lookahead() === \";\") {\n      var startColumn = column;\n      eatCharacter(2);\n      var text = \"\";\n\n      while (!isNewLine(char)) {\n        text += char;\n        eatCharacter();\n\n        if (char === undefined) {\n          break;\n        }\n      }\n\n      var endColumn = column;\n      pushCommentToken(text, {\n        type: \"leading\",\n        startColumn: startColumn,\n        endColumn: endColumn\n      });\n      continue;\n    } // (;\n\n\n    if (char === \"(\" && lookahead() === \";\") {\n      var _startColumn = column;\n      eatCharacter(2);\n      var _text = \"\"; // ;)\n\n      while (true) {\n        char = input[current];\n\n        if (char === \";\" && lookahead() === \")\") {\n          eatCharacter(2);\n          break;\n        }\n\n        _text += char;\n        eatCharacter();\n\n        if (isNewLine(char)) {\n          line++;\n          column = 0;\n        }\n      }\n\n      var _endColumn = column;\n      pushCommentToken(_text, {\n        type: \"block\",\n        startColumn: _startColumn,\n        endColumn: _endColumn\n      });\n      continue;\n    }\n\n    if (char === \"(\") {\n      pushOpenParenToken(char);\n      eatCharacter();\n      continue;\n    }\n\n    if (char === \"=\") {\n      pushEqualToken(char);\n      eatCharacter();\n      continue;\n    }\n\n    if (char === \")\") {\n      pushCloseParenToken(char);\n      eatCharacter();\n      continue;\n    }\n\n    if (isNewLine(char)) {\n      line++;\n      eatCharacter();\n      column = 0;\n      continue;\n    }\n\n    if (WHITESPACE.test(char)) {\n      eatCharacter();\n      continue;\n    }\n\n    if (char === \"$\") {\n      var _startColumn2 = column;\n      eatCharacter();\n      var value = \"\";\n\n      while (idchar.test(char)) {\n        value += char;\n        eatCharacter();\n      }\n\n      var _endColumn2 = column;\n      pushIdentifierToken(value, {\n        startColumn: _startColumn2,\n        endColumn: _endColumn2\n      });\n      continue;\n    }\n\n    if (NUMBERS.test(char) || NUMBER_KEYWORDS.test(lookahead(3, 0)) || char === \"-\" || char === \"+\") {\n      var _startColumn3 = column;\n\n      var _value = numberLiteralFSM.run(input.slice(current));\n\n      if (_value === \"\") {\n        throw new Error(getCodeFrame(input, line, column) + \"Unexpected character \" + JSON.stringify(char));\n      }\n\n      pushNumberToken(_value, {\n        startColumn: _startColumn3\n      });\n      eatCharacter(_value.length);\n\n      if (char && !PARENS.test(char) && !WHITESPACE.test(char)) {\n        throw new Error(getCodeFrame(input, line, column) + \"Unexpected character \" + JSON.stringify(char));\n      }\n\n      continue;\n    }\n\n    if (char === '\"') {\n      var _startColumn4 = column;\n      var _value2 = \"\";\n      eatCharacter(); // \"\n\n      while (char !== '\"') {\n        if (isNewLine(char)) {\n          throw new Error(getCodeFrame(input, line, column) + \"Unexpected character \" + JSON.stringify(char));\n        }\n\n        _value2 += char;\n        eatCharacter(); // char\n      }\n\n      eatCharacter(); // \"\n\n      var _endColumn3 = column;\n      pushStringToken(_value2, {\n        startColumn: _startColumn4,\n        endColumn: _endColumn3\n      });\n      continue;\n    }\n\n    if (LETTERS.test(char)) {\n      var _value3 = \"\";\n      var _startColumn5 = column;\n\n      while (char && LETTERS.test(char)) {\n        _value3 += char;\n        eatCharacter();\n      }\n      /*\n       * Handle MemberAccess\n       */\n\n\n      if (char === \".\") {\n        var dotStartColumn = column;\n\n        if (valtypes.indexOf(_value3) !== -1) {\n          pushValtypeToken(_value3, {\n            startColumn: _startColumn5\n          });\n        } else {\n          pushNameToken(_value3);\n        }\n\n        eatCharacter();\n        _value3 = \"\";\n        var nameStartColumn = column;\n\n        while (LETTERS.test(char)) {\n          _value3 += char;\n          eatCharacter();\n        }\n\n        pushDotToken(\".\", {\n          startColumn: dotStartColumn\n        });\n        pushNameToken(_value3, {\n          startColumn: nameStartColumn\n        });\n        continue;\n      }\n      /*\n       * Handle keywords\n       */\n      // $FlowIgnore\n\n\n      if (typeof keywords[_value3] === \"string\") {\n        pushKeywordToken(_value3, {\n          startColumn: _startColumn5\n        });\n        continue;\n      }\n      /*\n       * Handle types\n       */\n\n\n      if (valtypes.indexOf(_value3) !== -1) {\n        pushValtypeToken(_value3, {\n          startColumn: _startColumn5\n        });\n        continue;\n      }\n      /*\n       * Handle literals\n       */\n\n\n      pushNameToken(_value3, {\n        startColumn: _startColumn5\n      });\n      continue;\n    }\n\n    throw new Error(getCodeFrame(input, line, column) + \"Unexpected character \" + JSON.stringify(char));\n  }\n\n  return tokens;\n}\n\nvar tokens = tokenTypes;\nexports.tokens = tokens;"},"sourceMaps":null,"error":null,"hash":"a278bd69015e190bf441d9365d4835ad","cacheData":{"env":{}}}